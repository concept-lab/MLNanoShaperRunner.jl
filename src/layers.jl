using Lux
using ConcreteStructs
using GeometryBasics
using Random
using SimpleChains: static
using Adapt
using StructArrays
using Distances
using ChainRulesCore

struct Batch{T<:AbstractArray}
	field::Vector{T}
end

@concrete struct DeepSet <: Lux.AbstractExplicitContainerLayer{(:prepross,)}
    prepross
end

function (f::DeepSet)(set::AbstractVector{<:AbstractArray}, ps, st)
    trace("input size", length(set))
    sum(set) do arg
        Lux.apply(f.prepross, arg, ps, st) |> first
	end / sqrt(length(set)), st
end
function (f::DeepSet)(arg::StructArray, ps, st)
    trace("input size", length(arg))
	sum(Lux.apply(f.prepross, arg, ps, st) |> first) / sqrt(length(arg)), st
end

"""
Training information used in model training.
# Fields
- `atoms`: the set of atoms used as model input
- `skin` : the Surface generated by Nanoshaper
"""
struct TrainingData{T <: Number}
    atoms::StructVector{Sphere{T}}
    skin::GeometryBasics.Mesh
end


struct ModelInput{T <: Number}
    point::Point3{T}
    atoms::StructVector{Sphere{T}} #Set
end

struct PreprocessData{T <: Number}
    dot::T
    r_1::T
    r_2::T
    d_1::T
    d_2::T
end

"""
Encoding(n_dotₛ,n_Dₛ,cut_distance)

A lux layer which embed angular and radial `PreprocessData` into a feature vector invariant by translation and rotations.

# Arguments
- `n_dotₛ`: Integer specifying the number of anguar features 
- `n_Dₛ`: Integer specifying the number of radial features 
- `cut_distance`: The maximun distance of intaraction between atoms 
# Input
- `(;dot,r_1,r_2,d_1,d_2)`:`PreprocessData`, the dot product,the atoms radii and the distances between the reference point and the atoms. 
# Output
- `x`: a `Vector` representing the encoded features:
```math
x_{ij} = (\\frac{1}{2} + \\frac{dot - dot_{si}}{4})^\\eta * \\exp(-\\zeta ~ ( \\frac{d_1 + d_2}{2} - D_{si} ) ) \\times cut(d_1) \\times cut(d_2) 
```
"""
struct Encoding{T <: Number} <: Lux.AbstractExplicitLayer
    n_dotₛ::Int
    n_Dₛ::Int
    cut_distance::T
end

function Lux.initialparameters(::AbstractRNG, l::Encoding{T}) where {T}
    (dotsₛ = reshape(collect(range(T(0), T(1); length = l.n_dotₛ)), 1, :),
        Dₛ = reshape(collect(range(T(0), l.cut_distance; length = l.n_Dₛ)), :, 1),
        η = ones(T, 1, 1) ./ l.n_dotₛ,
        ζ = ones(T, 1, 1) ./ l.n_Dₛ)
end
Lux.initialstates(::AbstractRNG, l::Encoding) = (;)

function mergedims(x::AbstractArray, dims::AbstractRange)
    pre = size(x)[begin:(first(dims) - 1)]
    merged = size(x)[dims]
    post = size(x)[(last(dims) + 1):end]
    reshape(x, (pre..., prod(merged), post...))
end

function (l::Encoding{T})(input::StructArray{PreprocessData{T}},
        (; dotsₛ, η, ζ, Dₛ),
        st) where {T}
    (; dot, d_1, d_2, r_1, r_2) = input |> trace("input")
    encoded = ((2 .+ dot .- tanh.(dotsₛ)) ./ 4) .^ ζ .*
              exp.(-η .* ((d_1 .+ d_2) ./ 2 .- Dₛ) .^ 2) .*
              cut.(l.cut_distance, d_1) .*
              cut.(l.cut_distance, d_2)
    res = vcat(map((encoded, (r_1 .+ r_2) ./ 2, abs.(r_1 .- r_2))) do x
        mergedims(x, 1:2)
    end...)
    res |> trace("features"), st
end
function (l::Encoding{T})(x::PreprocessData, ps, st) where {T}
    l(StructVector{PreprocessData{T}}(dot = [x.dot],
            r_1 = [x.r_1],
            r_2 = [x.r_2],
            d_1 = [x.d_1],
            d_2 = [x.d_2]),
        ps,
        st)
end

function cut(cut_radius::Number, r::Number)
    if r >= cut_radius
        zero(r)
    else
        (1 + cos(π * r / cut_radius)) / 2
    end
end

function preprocessing((; point, atoms)::ModelInput)
    map(Iterators.product(atoms, atoms)) do (atom1, atom2)::Tuple{Sphere, Sphere}
        d_1 = euclidean(point, atom1.center)
        d_2 = euclidean(point, atom2.center)
        dot = (atom1.center - point) ⋅ (atom2.center - point) / (d_1 * d_2 + 1.0f-8)
        PreprocessData(dot, atom1.r, atom2.r, d_1, d_2)
    end |> vec
end
function struct_stack(x::AbstractArray{PreprocessData{T}}) where {T}
    x = StructVector{PreprocessData{T}}(dot = getfield.(x, :dot),
        r_1 = getfield.(x, :r_1),
        r_2 = getfield.(x, :r_2),
        d_1 = getfield.(x, :d_1),
        d_2 = getfield.(x, :d_2))
    reshape(x, 1, 1, size(x)...) |> trace("struct array")
end

function trace(message::String, x)
    @debug message x
    x
end

trace(message::String) = x -> trace(message, x)
function ChainRulesCore.rrule(::typeof(trace), message, x)
    y = trace(message, x)
    function trace_pullback(y_hat)
        @debug "derivation $message" y_hat
        NoTangent(), NoTangent(), y_hat
    end
    return y, trace_pullback
end

function ChainRulesCore.rrule(::typeof(Base.getproperty), array::StructArray, field::Symbol)
    member = getproperty(array, field)
    function getproperty_pullback(y_hat)
        NoTangent(),
        StructArray(; (f => if f == field
            y_hat
        else
			fill(ZeroTangent(),size(y_hat))
        end
                       for f in propertynames(array))...)
        NoTangent()
    end
    member, getproperty_pullback
end
